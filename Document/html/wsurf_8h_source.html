<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>windage library: D:/Workspace/2009. Fall/Workspace/SpatialInteraction/source/windageLib/windage/Tracker/FAST/wsurf.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>D:/Workspace/2009. Fall/Workspace/SpatialInteraction/source/windageLib/windage/Tracker/FAST/wsurf.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* ========================================================================</span>
<a name="l00002"></a>00002 <span class="comment"> * PROJECT: windage Library</span>
<a name="l00003"></a>00003 <span class="comment"> * ========================================================================</span>
<a name="l00004"></a>00004 <span class="comment"> * This work is based on the original windage Library developed by</span>
<a name="l00005"></a>00005 <span class="comment"> *   Woonhyuk Baek</span>
<a name="l00006"></a>00006 <span class="comment"> *   Woontack Woo</span>
<a name="l00007"></a>00007 <span class="comment"> *   U-VR Lab, GIST of Gwangju in Korea.</span>
<a name="l00008"></a>00008 <span class="comment"> *   http://windage.googlecode.com/</span>
<a name="l00009"></a>00009 <span class="comment"> *   http://uvr.gist.ac.kr/</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * Copyright of the derived and new portions of this work</span>
<a name="l00012"></a>00012 <span class="comment"> *     (C) 2009 GIST U-VR Lab.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * This framework is free software; you can redistribute it and/or modify</span>
<a name="l00015"></a>00015 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00016"></a>00016 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00017"></a>00017 <span class="comment"> * (at your option) any later version.</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * This framework is distributed in the hope that it will be useful,</span>
<a name="l00020"></a>00020 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00021"></a>00021 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00022"></a>00022 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00025"></a>00025 <span class="comment"> * along with this framework; if not, write to the Free Software</span>
<a name="l00026"></a>00026 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * For further information please contact </span>
<a name="l00029"></a>00029 <span class="comment"> *   Woonhyuk Baek</span>
<a name="l00030"></a>00030 <span class="comment"> *   &lt;windage@live.com&gt;</span>
<a name="l00031"></a>00031 <span class="comment"> *   GIST U-VR Lab.</span>
<a name="l00032"></a>00032 <span class="comment"> *   Department of Information and Communication</span>
<a name="l00033"></a>00033 <span class="comment"> *   Gwangju Institute of Science and Technology</span>
<a name="l00034"></a>00034 <span class="comment"> *   1, Oryong-dong, Buk-gu, Gwangju</span>
<a name="l00035"></a>00035 <span class="comment"> *   South Korea</span>
<a name="l00036"></a>00036 <span class="comment"> * ========================================================================</span>
<a name="l00037"></a>00037 <span class="comment"> ** @author   Woonhyuk Baek</span>
<a name="l00038"></a>00038 <span class="comment"> * ======================================================================== */</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#ifndef _W_SURF_H_</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define _W_SURF_H_</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="comment">// modified SURF by windage</span>
<a name="l00046"></a>00046 <span class="comment"></span><span class="preprocessor">#include &lt;cv.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;cxmisc.h&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keyword">struct </span>CvSurfHF
<a name="l00050"></a>00050 {
<a name="l00051"></a>00051     <span class="keywordtype">int</span> p0, p1, p2, p3;
<a name="l00052"></a>00052     <span class="keywordtype">float</span> w;
<a name="l00053"></a>00053 };
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="keywordtype">float</span> wCalcHaarPattern( <span class="keyword">const</span> <span class="keywordtype">int</span>* origin, <span class="keyword">const</span> CvSurfHF* f, <span class="keywordtype">int</span> n )
<a name="l00056"></a>00056 {
<a name="l00057"></a>00057     <span class="keywordtype">double</span> d = 0;
<a name="l00058"></a>00058     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> k = 0; k &lt; n; k++ )
<a name="l00059"></a>00059         d += (origin[f[k].p0] + origin[f[k].p3] - origin[f[k].p1] - origin[f[k].p2])*f[k].w;
<a name="l00060"></a>00060     <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)d;
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="keyword">static</span> <span class="keywordtype">void</span> wResizeHaarPattern( <span class="keyword">const</span> <span class="keywordtype">int</span> src[][5], CvSurfHF* dst, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> oldSize, <span class="keywordtype">int</span> newSize, <span class="keywordtype">int</span> widthStep )
<a name="l00064"></a>00064 {
<a name="l00065"></a>00065     <span class="keywordtype">float</span> ratio = (float)newSize/oldSize;
<a name="l00066"></a>00066     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> k = 0; k &lt; n; k++ )
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068         <span class="keywordtype">int</span> dx1 = cvRound( ratio*src[k][0] );
<a name="l00069"></a>00069         <span class="keywordtype">int</span> dy1 = cvRound( ratio*src[k][1] );
<a name="l00070"></a>00070         <span class="keywordtype">int</span> dx2 = cvRound( ratio*src[k][2] );
<a name="l00071"></a>00071         <span class="keywordtype">int</span> dy2 = cvRound( ratio*src[k][3] );
<a name="l00072"></a>00072         dst[k].p0 = dy1*widthStep + dx1;
<a name="l00073"></a>00073         dst[k].p1 = dy2*widthStep + dx1;
<a name="l00074"></a>00074         dst[k].p2 = dy1*widthStep + dx2;
<a name="l00075"></a>00075         dst[k].p3 = dy2*widthStep + dx2;
<a name="l00076"></a>00076         dst[k].w = src[k][4]/((float)(dx2-dx1)*(dy2-dy1));
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keywordtype">int</span> wInterpolateKeypoint( <span class="keywordtype">float</span> N9[3][9], <span class="keywordtype">int</span> dx, <span class="keywordtype">int</span> dy, <span class="keywordtype">int</span> ds, CvSURFPoint *point )
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082     <span class="keywordtype">int</span> solve_ok;
<a name="l00083"></a>00083     <span class="keywordtype">float</span> A[9], x[3], b[3];
<a name="l00084"></a>00084     CvMat _A = cvMat(3, 3, CV_32F, A);
<a name="l00085"></a>00085     CvMat _x = cvMat(3, 1, CV_32F, x);                
<a name="l00086"></a>00086     CvMat _b = cvMat(3, 1, CV_32F, b);
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     b[0] = -(N9[1][5]-N9[1][3])/2;  <span class="comment">/* Negative 1st deriv with respect to x */</span>
<a name="l00089"></a>00089     b[1] = -(N9[1][7]-N9[1][1])/2;  <span class="comment">/* Negative 1st deriv with respect to y */</span>
<a name="l00090"></a>00090     b[2] = -(N9[2][4]-N9[0][4])/2;  <span class="comment">/* Negative 1st deriv with respect to s */</span>
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     A[0] = N9[1][3]-2*N9[1][4]+N9[1][5];            <span class="comment">/* 2nd deriv x, x */</span>
<a name="l00093"></a>00093     A[1] = (N9[1][8]-N9[1][6]-N9[1][2]+N9[1][0])/4; <span class="comment">/* 2nd deriv x, y */</span>
<a name="l00094"></a>00094     A[2] = (N9[2][5]-N9[2][3]-N9[0][5]+N9[0][3])/4; <span class="comment">/* 2nd deriv x, s */</span>
<a name="l00095"></a>00095     A[3] = A[1];                                    <span class="comment">/* 2nd deriv y, x */</span>
<a name="l00096"></a>00096     A[4] = N9[1][1]-2*N9[1][4]+N9[1][7];            <span class="comment">/* 2nd deriv y, y */</span>
<a name="l00097"></a>00097     A[5] = (N9[2][7]-N9[2][1]-N9[0][7]+N9[0][1])/4; <span class="comment">/* 2nd deriv y, s */</span>
<a name="l00098"></a>00098     A[6] = A[2];                                    <span class="comment">/* 2nd deriv s, x */</span>
<a name="l00099"></a>00099     A[7] = A[5];                                    <span class="comment">/* 2nd deriv s, y */</span>
<a name="l00100"></a>00100     A[8] = N9[0][4]-2*N9[1][4]+N9[2][4];            <span class="comment">/* 2nd deriv s, s */</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     solve_ok = cvSolve( &amp;_A, &amp;_b, &amp;_x );
<a name="l00103"></a>00103     <span class="keywordflow">if</span>( solve_ok )
<a name="l00104"></a>00104     {
<a name="l00105"></a>00105         point-&gt;pt.x += x[0]*dx;
<a name="l00106"></a>00106         point-&gt;pt.y += x[1]*dy;
<a name="l00107"></a>00107         point-&gt;size = cvRound( point-&gt;size + x[2]*ds ); 
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109     <span class="keywordflow">return</span> solve_ok;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="keyword">static</span> CvSeq* wFastHessianDetector( <span class="keyword">const</span> CvMat* sum, <span class="keyword">const</span> CvMat* mask_sum,
<a name="l00113"></a>00113     CvMemStorage* storage, <span class="keyword">const</span> CvSURFParams* params )
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115     CvSeq* points = cvCreateSeq( 0, <span class="keyword">sizeof</span>(CvSeq), <span class="keyword">sizeof</span>(CvSURFPoint), storage );
<a name="l00116"></a>00116     
<a name="l00117"></a>00117     <span class="comment">/* Wavelet size at first layer of first octave. */</span> 
<a name="l00118"></a>00118     <span class="keyword">const</span> <span class="keywordtype">int</span> HAAR_SIZE0 = 9;    
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="comment">/* Wavelet size increment between layers. This should be an even number, </span>
<a name="l00121"></a>00121 <span class="comment">       such that the wavelet sizes in an octave are either all even or all odd.</span>
<a name="l00122"></a>00122 <span class="comment">       This ensures that when looking for the neighbours of a sample, the layers</span>
<a name="l00123"></a>00123 <span class="comment">       above and below are aligned correctly. */</span>
<a name="l00124"></a>00124     <span class="keyword">const</span> <span class="keywordtype">int</span> HAAR_SIZE_INC = 6; 
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="comment">/* Sampling step along image x and y axes at first octave. This is doubled</span>
<a name="l00127"></a>00127 <span class="comment">       for each additional octave. WARNING: Increasing this improves speed, </span>
<a name="l00128"></a>00128 <span class="comment">       however keypoint extraction becomes unreliable. */</span>
<a name="l00129"></a>00129     <span class="keyword">const</span> <span class="keywordtype">int</span> SAMPLE_STEP0 = 1; 
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <span class="comment">/* Wavelet Data */</span>
<a name="l00133"></a>00133     <span class="keyword">const</span> <span class="keywordtype">int</span> NX=3, NY=3, NXY=4, NM=1;
<a name="l00134"></a>00134     <span class="keyword">const</span> <span class="keywordtype">int</span> dx_s[NX][5] = { {0, 2, 3, 7, 1}, {3, 2, 6, 7, -2}, {6, 2, 9, 7, 1} };
<a name="l00135"></a>00135     <span class="keyword">const</span> <span class="keywordtype">int</span> dy_s[NY][5] = { {2, 0, 7, 3, 1}, {2, 3, 7, 6, -2}, {2, 6, 7, 9, 1} };
<a name="l00136"></a>00136     <span class="keyword">const</span> <span class="keywordtype">int</span> dxy_s[NXY][5] = { {1, 1, 4, 4, 1}, {5, 1, 8, 4, -1}, {1, 5, 4, 8, -1}, {5, 5, 8, 8, 1} };
<a name="l00137"></a>00137     <span class="keyword">const</span> <span class="keywordtype">int</span> dm[NM][5] = { {0, 0, 9, 9, 1} };
<a name="l00138"></a>00138     CvSurfHF Dx[NX], Dy[NY], Dxy[NXY], Dm;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140     CvMat** dets = (CvMat**)cvStackAlloc((params-&gt;nOctaveLayers+2)*<span class="keyword">sizeof</span>(dets[0]));
<a name="l00141"></a>00141     CvMat** traces = (CvMat**)cvStackAlloc((params-&gt;nOctaveLayers+2)*<span class="keyword">sizeof</span>(traces[0]));
<a name="l00142"></a>00142     <span class="keywordtype">int</span> *sizes = (<span class="keywordtype">int</span>*)cvStackAlloc((params-&gt;nOctaveLayers+2)*<span class="keyword">sizeof</span>(sizes[0]));
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keywordtype">double</span> dx = 0, dy = 0, dxy = 0;
<a name="l00145"></a>00145     <span class="keywordtype">int</span> octave, layer, sampleStep, size, margin;
<a name="l00146"></a>00146     <span class="keywordtype">int</span> rows, cols;
<a name="l00147"></a>00147     <span class="keywordtype">int</span> i, j, sum_i, sum_j;
<a name="l00148"></a>00148     <span class="keyword">const</span> <span class="keywordtype">int</span>* s_ptr;
<a name="l00149"></a>00149     <span class="keywordtype">float</span> *det_ptr, *trace_ptr;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151     <span class="comment">/* Allocate enough space for hessian determinant and trace matrices at the </span>
<a name="l00152"></a>00152 <span class="comment">       first octave. Clearing these initially or between octaves is not</span>
<a name="l00153"></a>00153 <span class="comment">       required, since all values that are accessed are first calculated */</span>
<a name="l00154"></a>00154     <span class="keywordflow">for</span>( layer = 0; layer &lt;= params-&gt;nOctaveLayers+1; layer++ )
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156         dets[layer]   = cvCreateMat( (sum-&gt;rows-1)/SAMPLE_STEP0, (sum-&gt;cols-1)/SAMPLE_STEP0, CV_32FC1 );
<a name="l00157"></a>00157         traces[layer] = cvCreateMat( (sum-&gt;rows-1)/SAMPLE_STEP0, (sum-&gt;cols-1)/SAMPLE_STEP0, CV_32FC1 );
<a name="l00158"></a>00158     }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordflow">for</span>( octave = 0, sampleStep=SAMPLE_STEP0; octave &lt; params-&gt;nOctaves; octave++, sampleStep*=2 )
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162         <span class="comment">/* Hessian determinant and trace sample array size in this octave */</span>
<a name="l00163"></a>00163         rows = (sum-&gt;rows-1)/sampleStep;
<a name="l00164"></a>00164         cols = (sum-&gt;cols-1)/sampleStep;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="comment">/* Calculate the determinant and trace of the hessian */</span>
<a name="l00167"></a>00167         <span class="keywordflow">for</span>( layer = 0; layer &lt;= params-&gt;nOctaveLayers+1; layer++ )
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169             sizes[layer] = size = (HAAR_SIZE0+HAAR_SIZE_INC*layer)&lt;&lt;octave;
<a name="l00170"></a>00170             wResizeHaarPattern( dx_s, Dx, NX, 9, size, sum-&gt;cols );
<a name="l00171"></a>00171             wResizeHaarPattern( dy_s, Dy, NY, 9, size, sum-&gt;cols );
<a name="l00172"></a>00172             wResizeHaarPattern( dxy_s, Dxy, NXY, 9, size, sum-&gt;cols );
<a name="l00173"></a>00173             <span class="comment">/*printf( &quot;octave=%d layer=%d size=%d rows=%d cols=%d\n&quot;, octave, layer, size, rows, cols );*/</span>
<a name="l00174"></a>00174             
<a name="l00175"></a>00175             margin = (size/2)/sampleStep;
<a name="l00176"></a>00176             <span class="keywordflow">for</span>( sum_i=0, i=margin; sum_i&lt;=(sum-&gt;rows-1)-size; sum_i+=sampleStep, i++ )
<a name="l00177"></a>00177             {
<a name="l00178"></a>00178                 s_ptr = sum-&gt;data.i + sum_i*sum-&gt;cols;
<a name="l00179"></a>00179                 det_ptr = dets[layer]-&gt;data.fl + i*dets[layer]-&gt;cols + margin;
<a name="l00180"></a>00180                 trace_ptr = traces[layer]-&gt;data.fl + i*traces[layer]-&gt;cols + margin;
<a name="l00181"></a>00181                 <span class="keywordflow">for</span>( sum_j=0, j=margin; sum_j&lt;=(sum-&gt;cols-1)-size; sum_j+=sampleStep, j++ )
<a name="l00182"></a>00182                 {
<a name="l00183"></a>00183                     dx  = wCalcHaarPattern( s_ptr, Dx, 3 );
<a name="l00184"></a>00184                     dy  = wCalcHaarPattern( s_ptr, Dy, 3 );
<a name="l00185"></a>00185                     dxy = wCalcHaarPattern( s_ptr, Dxy, 4 );
<a name="l00186"></a>00186                     s_ptr+=sampleStep;
<a name="l00187"></a>00187                     *det_ptr++ = (float)(dx*dy - 0.81*dxy*dxy);
<a name="l00188"></a>00188                     *trace_ptr++ = (float)(dx + dy);
<a name="l00189"></a>00189                 }
<a name="l00190"></a>00190             }
<a name="l00191"></a>00191         }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193         <span class="comment">/* Find maxima in the determinant of the hessian */</span>
<a name="l00194"></a>00194         <span class="keywordflow">for</span>( layer = 1; layer &lt;= params-&gt;nOctaveLayers; layer++ )
<a name="l00195"></a>00195         {
<a name="l00196"></a>00196             size = sizes[layer];
<a name="l00197"></a>00197             wResizeHaarPattern( dm, &amp;Dm, NM, 9, size, mask_sum ? mask_sum-&gt;cols : sum-&gt;cols );
<a name="l00198"></a>00198             
<a name="l00199"></a>00199             <span class="comment">/* Ignore pixels without a 3x3 neighbourhood in the layer above */</span>
<a name="l00200"></a>00200             margin = (sizes[layer+1]/2)/sampleStep+1; 
<a name="l00201"></a>00201             <span class="keywordflow">for</span>( i = margin; i &lt; rows-margin; i++ )
<a name="l00202"></a>00202             {
<a name="l00203"></a>00203                 det_ptr = dets[layer]-&gt;data.fl + i*dets[layer]-&gt;cols;
<a name="l00204"></a>00204                 trace_ptr = traces[layer]-&gt;data.fl + i*traces[layer]-&gt;cols;
<a name="l00205"></a>00205                 <span class="keywordflow">for</span>( j = margin; j &lt; cols-margin; j++ )
<a name="l00206"></a>00206                 {
<a name="l00207"></a>00207                     <span class="keywordtype">float</span> val0 = det_ptr[j];
<a name="l00208"></a>00208                     <span class="keywordflow">if</span>( val0 &gt; params-&gt;hessianThreshold )
<a name="l00209"></a>00209                     {
<a name="l00210"></a>00210                         <span class="comment">/* Coordinates for the start of the wavelet in the sum image. There   </span>
<a name="l00211"></a>00211 <span class="comment">                           is some integer division involved, so don&apos;t try to simplify this</span>
<a name="l00212"></a>00212 <span class="comment">                           (cancel out sampleStep) without checking the result is the same */</span>
<a name="l00213"></a>00213                         <span class="keywordtype">int</span> sum_i = sampleStep*(i-(size/2)/sampleStep);
<a name="l00214"></a>00214                         <span class="keywordtype">int</span> sum_j = sampleStep*(j-(size/2)/sampleStep);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216                         <span class="comment">/* The 3x3x3 neighbouring samples around the maxima. </span>
<a name="l00217"></a>00217 <span class="comment">                           The maxima is included at N9[1][4] */</span>
<a name="l00218"></a>00218                         <span class="keywordtype">int</span> c = dets[layer]-&gt;cols;
<a name="l00219"></a>00219                         <span class="keyword">const</span> <span class="keywordtype">float</span> *det1 = dets[layer-1]-&gt;data.fl + i*c + j;
<a name="l00220"></a>00220                         <span class="keyword">const</span> <span class="keywordtype">float</span> *det2 = dets[layer]-&gt;data.fl   + i*c + j;
<a name="l00221"></a>00221                         <span class="keyword">const</span> <span class="keywordtype">float</span> *det3 = dets[layer+1]-&gt;data.fl + i*c + j;
<a name="l00222"></a>00222                         <span class="keywordtype">float</span> N9[3][9] = { { det1[-c-1], det1[-c], det1[-c+1],          
<a name="l00223"></a>00223                                              det1[-1]  , det1[0] , det1[1],
<a name="l00224"></a>00224                                              det1[c-1] , det1[c] , det1[c+1]  },
<a name="l00225"></a>00225                                            { det2[-c-1], det2[-c], det2[-c+1],       
<a name="l00226"></a>00226                                              det2[-1]  , det2[0] , det2[1],
<a name="l00227"></a>00227                                              det2[c-1] , det2[c] , det2[c+1 ] },
<a name="l00228"></a>00228                                            { det3[-c-1], det3[-c], det3[-c+1],       
<a name="l00229"></a>00229                                              det3[-1  ], det3[0] , det3[1],
<a name="l00230"></a>00230                                              det3[c-1] , det3[c] , det3[c+1 ] } };
<a name="l00231"></a>00231 
<a name="l00232"></a>00232                         <span class="comment">/* Check the mask - why not just check the mask at the center of the wavelet? */</span>
<a name="l00233"></a>00233                         <span class="keywordflow">if</span>( mask_sum )
<a name="l00234"></a>00234                         {
<a name="l00235"></a>00235                             <span class="keyword">const</span> <span class="keywordtype">int</span>* mask_ptr = mask_sum-&gt;data.i +  mask_sum-&gt;cols*sum_i + sum_j;
<a name="l00236"></a>00236                             <span class="keywordtype">float</span> mval = wCalcHaarPattern( mask_ptr, &amp;Dm, 1 );
<a name="l00237"></a>00237                             <span class="keywordflow">if</span>( mval &lt; 0.5 )
<a name="l00238"></a>00238                                 <span class="keywordflow">continue</span>;
<a name="l00239"></a>00239                         }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241                         <span class="comment">/* Non-maxima suppression. val0 is at N9[1][4]*/</span>
<a name="l00242"></a>00242                         <span class="keywordflow">if</span>( val0 &gt; N9[0][0] &amp;&amp; val0 &gt; N9[0][1] &amp;&amp; val0 &gt; N9[0][2] &amp;&amp;
<a name="l00243"></a>00243                             val0 &gt; N9[0][3] &amp;&amp; val0 &gt; N9[0][4] &amp;&amp; val0 &gt; N9[0][5] &amp;&amp;
<a name="l00244"></a>00244                             val0 &gt; N9[0][6] &amp;&amp; val0 &gt; N9[0][7] &amp;&amp; val0 &gt; N9[0][8] &amp;&amp;
<a name="l00245"></a>00245                             val0 &gt; N9[1][0] &amp;&amp; val0 &gt; N9[1][1] &amp;&amp; val0 &gt; N9[1][2] &amp;&amp;
<a name="l00246"></a>00246                             val0 &gt; N9[1][3]                    &amp;&amp; val0 &gt; N9[1][5] &amp;&amp;
<a name="l00247"></a>00247                             val0 &gt; N9[1][6] &amp;&amp; val0 &gt; N9[1][7] &amp;&amp; val0 &gt; N9[1][8] &amp;&amp;
<a name="l00248"></a>00248                             val0 &gt; N9[2][0] &amp;&amp; val0 &gt; N9[2][1] &amp;&amp; val0 &gt; N9[2][2] &amp;&amp;
<a name="l00249"></a>00249                             val0 &gt; N9[2][3] &amp;&amp; val0 &gt; N9[2][4] &amp;&amp; val0 &gt; N9[2][5] &amp;&amp;
<a name="l00250"></a>00250                             val0 &gt; N9[2][6] &amp;&amp; val0 &gt; N9[2][7] &amp;&amp; val0 &gt; N9[2][8] )
<a name="l00251"></a>00251                         {
<a name="l00252"></a>00252                             <span class="comment">/* Calculate the wavelet center coordinates for the maxima */</span>
<a name="l00253"></a>00253                             <span class="keywordtype">double</span> center_i = sum_i + (double)(size-1)/2;
<a name="l00254"></a>00254                             <span class="keywordtype">double</span> center_j = sum_j + (double)(size-1)/2;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256                             CvSURFPoint point = cvSURFPoint( cvPoint2D32f(center_j,center_i), 
<a name="l00257"></a>00257                                                              CV_SIGN(trace_ptr[j]), sizes[layer], 0, val0 );
<a name="l00258"></a>00258                            
<a name="l00259"></a>00259                             <span class="comment">/* Interpolate maxima location within the 3x3x3 neighbourhood  */</span>
<a name="l00260"></a>00260                             <span class="keywordtype">int</span> ds = sizes[layer]-sizes[layer-1];
<a name="l00261"></a>00261                             <span class="keywordtype">int</span> interp_ok = wInterpolateKeypoint( N9, sampleStep, sampleStep, ds, &amp;point );
<a name="l00262"></a>00262 
<a name="l00263"></a>00263                             <span class="comment">/* Sometimes the interpolation step gives a negative size etc. */</span>
<a name="l00264"></a>00264                             <span class="keywordflow">if</span>( interp_ok &amp;&amp; point.size &gt;= 1 &amp;&amp;
<a name="l00265"></a>00265                                 point.pt.x &gt;= 0 &amp;&amp; point.pt.x &lt;= (sum-&gt;cols-1) &amp;&amp;
<a name="l00266"></a>00266                                 point.pt.y &gt;= 0 &amp;&amp; point.pt.y &lt;= (sum-&gt;rows-1) )
<a name="l00267"></a>00267                             {    
<a name="l00268"></a>00268                                 <span class="comment">/*printf( &quot;Keypoint %f %f %d\n&quot;, point.pt.x, point.pt.y, point.size );*/</span>
<a name="l00269"></a>00269                                 cvSeqPush( points, &amp;point );
<a name="l00270"></a>00270                             }    
<a name="l00271"></a>00271                         }
<a name="l00272"></a>00272                     }
<a name="l00273"></a>00273                 }
<a name="l00274"></a>00274             }
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     <span class="comment">/* Clean-up */</span>
<a name="l00279"></a>00279     <span class="keywordflow">for</span>( layer = 0; layer &lt;= params-&gt;nOctaveLayers+1; layer++ )
<a name="l00280"></a>00280     {
<a name="l00281"></a>00281         cvReleaseMat( &amp;dets[layer] );
<a name="l00282"></a>00282         cvReleaseMat( &amp;traces[layer] );
<a name="l00283"></a>00283     }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     <span class="keywordflow">return</span> points;
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">/****************************************************************************************\</span>
<a name="l00289"></a>00289 <span class="comment">                                     Gaussian Blur</span>
<a name="l00290"></a>00290 <span class="comment">\****************************************************************************************/</span>
<a name="l00291"></a>00291 <span class="keywordtype">void</span> getGaussianKernel( CvMat* kernel, <span class="keywordtype">int</span> n, <span class="keywordtype">double</span> sigma, <span class="keywordtype">int</span> ktype )
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293     <span class="keyword">const</span> <span class="keywordtype">int</span> SMALL_GAUSSIAN_SIZE = 7;
<a name="l00294"></a>00294     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">float</span> small_gaussian_tab[][SMALL_GAUSSIAN_SIZE/2+1] =
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296         {1.f},
<a name="l00297"></a>00297         {0.5f, 0.25f},
<a name="l00298"></a>00298         {0.375f, 0.25f, 0.0625f},
<a name="l00299"></a>00299         {0.28125f, 0.21875f, 0.109375f, 0.03125f}
<a name="l00300"></a>00300     };
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="keyword">const</span> <span class="keywordtype">float</span>* fixed_kernel = n &lt;= SMALL_GAUSSIAN_SIZE &amp;&amp; sigma &lt;= 0 ?
<a name="l00303"></a>00303         small_gaussian_tab[n&gt;&gt;1] : 0;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="comment">//    CV_Assert( ktype == CV_32F || ktype == CV_64F );</span>
<a name="l00306"></a>00306 <span class="comment">//    Mat kernel(n, 1, ktype);</span>
<a name="l00307"></a>00307         <span class="keywordtype">float</span>* cf = (<span class="keywordtype">float</span>*)kernel-&gt;data.fl;
<a name="l00308"></a>00308         <span class="keywordtype">double</span>* cd = (<span class="keywordtype">double</span>*)kernel-&gt;data.db;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordtype">double</span> sigmaX = sigma &gt; 0 ? sigma : (n/2 - 1)*0.3 + 0.8;
<a name="l00311"></a>00311     <span class="keywordtype">double</span> scale2X = -0.5/(sigmaX*sigmaX);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keywordtype">double</span> sum = fixed_kernel ? -fixed_kernel[0] : -1.;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="keywordtype">int</span> i;
<a name="l00316"></a>00316     <span class="keywordflow">for</span>( i = 0; i &lt;= n/2; i++ )
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318                 <span class="keywordtype">double</span> temp = scale2X*i*i;
<a name="l00319"></a>00319         <span class="keywordtype">double</span> t = fixed_kernel ? (double)fixed_kernel[i] : temp*temp;
<a name="l00320"></a>00320         <span class="keywordflow">if</span>( ktype == CV_32F )
<a name="l00321"></a>00321         {
<a name="l00322"></a>00322             cf[n/2+i] = (float)t;
<a name="l00323"></a>00323             sum += cf[n/2+i]*2;
<a name="l00324"></a>00324         }
<a name="l00325"></a>00325         <span class="keywordflow">else</span>
<a name="l00326"></a>00326         {
<a name="l00327"></a>00327             cd[n/2+i] = t;
<a name="l00328"></a>00328             sum += cd[n/2+i]*2;
<a name="l00329"></a>00329         }
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332     sum = 1./sum;
<a name="l00333"></a>00333     <span class="keywordflow">for</span>( i = 0; i &lt;= n/2; i++ )
<a name="l00334"></a>00334     {
<a name="l00335"></a>00335         <span class="keywordflow">if</span>( ktype == CV_32F )
<a name="l00336"></a>00336             cf[n/2+i] = cf[n/2-i] = (float)(cf[n/2+i]*sum);
<a name="l00337"></a>00337         <span class="keywordflow">else</span>
<a name="l00338"></a>00338             cd[n/2+i] = cd[n/2-i] = cd[n/2+i]*sum;
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">//    return kernel;</span>
<a name="l00342"></a>00342 }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">// modified SURF descriptor</span>
<a name="l00345"></a>00345 <span class="keywordtype">void</span> wExtractSURF( <span class="keyword">const</span> CvArr* _img, <span class="keyword">const</span> CvArr* _mask,
<a name="l00346"></a>00346                                                         CvSeq** _keypoints, CvSeq** _descriptors,
<a name="l00347"></a>00347                                                         CvMemStorage* storage, CvSURFParams params,
<a name="l00348"></a>00348                                                         <span class="keywordtype">int</span> useProvidedKeyPts)
<a name="l00349"></a>00349 {
<a name="l00350"></a>00350     CvMat *sum = 0, *mask1 = 0, *mask_sum = 0, **win_bufs = 0;
<a name="l00351"></a>00351 
<a name="l00352"></a>00352     <span class="keywordflow">if</span>( _keypoints &amp;&amp; !useProvidedKeyPts ) <span class="comment">// If useProvidedKeyPts!=0 we&apos;ll use current contents of &quot;*_keypoints&quot;</span>
<a name="l00353"></a>00353         *_keypoints = 0;
<a name="l00354"></a>00354     <span class="keywordflow">if</span>( _descriptors )
<a name="l00355"></a>00355         *_descriptors = 0;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357     <span class="comment">/* Radius of the circle in which to sample gradients to assign an </span>
<a name="l00358"></a>00358 <span class="comment">       orientation */</span>
<a name="l00359"></a>00359     <span class="keyword">const</span> <span class="keywordtype">int</span> ORI_RADIUS = 6; 
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <span class="comment">/* The size of the sliding window (in degrees) used to assign an </span>
<a name="l00362"></a>00362 <span class="comment">       orientation */</span>
<a name="l00363"></a>00363     <span class="keyword">const</span> <span class="keywordtype">int</span> ORI_WIN = 60;   
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <span class="comment">/* Increment used for the orientation sliding window (in degrees) */</span>
<a name="l00366"></a>00366     <span class="keyword">const</span> <span class="keywordtype">int</span> ORI_SEARCH_INC = 10;
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     <span class="comment">/* Standard deviation of the Gaussian used to weight the gradient samples</span>
<a name="l00369"></a>00369 <span class="comment">       used to assign an orientation */</span> 
<a name="l00370"></a>00370     <span class="keyword">const</span> <span class="keywordtype">float</span> ORI_SIGMA = 2.5f;
<a name="l00371"></a>00371 
<a name="l00372"></a>00372     <span class="comment">/* Standard deviation of the Gaussian used to weight the gradient samples</span>
<a name="l00373"></a>00373 <span class="comment">       used to build a keypoint descriptor */</span>
<a name="l00374"></a>00374     <span class="keyword">const</span> <span class="keywordtype">float</span> DESC_SIGMA = 3.3f;
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377     <span class="comment">/* X and Y gradient wavelet data */</span>
<a name="l00378"></a>00378     <span class="keyword">const</span> <span class="keywordtype">int</span> NX=2, NY=2;
<a name="l00379"></a>00379     <span class="keywordtype">int</span> dx_s[NX][5] = {{0, 0, 2, 4, -1}, {2, 0, 4, 4, 1}};
<a name="l00380"></a>00380     <span class="keywordtype">int</span> dy_s[NY][5] = {{0, 0, 4, 2, 1}, {0, 2, 4, 4, -1}};
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     CvSeq *keypoints, *descriptors = 0;
<a name="l00383"></a>00383     CvMat imghdr, *img = cvGetMat(_img, &amp;imghdr);
<a name="l00384"></a>00384     CvMat maskhdr, *mask = _mask ? cvGetMat(_mask, &amp;maskhdr) : 0;
<a name="l00385"></a>00385     
<a name="l00386"></a>00386     <span class="keyword">const</span> <span class="keywordtype">int</span> max_ori_samples = (2*ORI_RADIUS+1)*(2*ORI_RADIUS+1);
<a name="l00387"></a>00387     <span class="keywordtype">int</span> descriptor_size = 36;
<a name="l00388"></a>00388     <span class="keyword">const</span> <span class="keywordtype">int</span> descriptor_data_type = CV_32F;
<a name="l00389"></a>00389     <span class="keyword">const</span> <span class="keywordtype">int</span> PATCH_SZ = 15;
<a name="l00390"></a>00390     <span class="keywordtype">float</span> DW[PATCH_SZ][PATCH_SZ];
<a name="l00391"></a>00391     CvMat _DW = cvMat(PATCH_SZ, PATCH_SZ, CV_32F, DW);
<a name="l00392"></a>00392     CvPoint apt[max_ori_samples];
<a name="l00393"></a>00393     <span class="keywordtype">float</span> apt_w[max_ori_samples];
<a name="l00394"></a>00394     <span class="keywordtype">int</span> i, j, k, nangle0 = 0, N;
<a name="l00395"></a>00395     <span class="keywordtype">int</span> nthreads = cvGetNumThreads();
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="comment">//    CV_Assert(img != 0);</span>
<a name="l00398"></a>00398 <span class="comment">//    CV_Assert(CV_MAT_TYPE(img-&gt;type) == CV_8UC1);</span>
<a name="l00399"></a>00399 <span class="comment">//    CV_Assert(mask == 0 || (CV_ARE_SIZES_EQ(img,mask) &amp;&amp; CV_MAT_TYPE(mask-&gt;type) == CV_8UC1));</span>
<a name="l00400"></a>00400 <span class="comment">//    CV_Assert(storage != 0);</span>
<a name="l00401"></a>00401 <span class="comment">//    CV_Assert(params.hessianThreshold &gt;= 0);</span>
<a name="l00402"></a>00402 <span class="comment">//    CV_Assert(params.nOctaves &gt; 0);</span>
<a name="l00403"></a>00403 <span class="comment">//    CV_Assert(params.nOctaveLayers &gt; 0);</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     sum = cvCreateMat( img-&gt;height+1, img-&gt;width+1, CV_32SC1 );
<a name="l00406"></a>00406     cvIntegral( img, sum );
<a name="l00407"></a>00407         
<a name="l00408"></a>00408         <span class="comment">// Compute keypoints only if we are not asked for evaluating the descriptors are some given locations:</span>
<a name="l00409"></a>00409         <span class="keywordflow">if</span> (!useProvidedKeyPts)
<a name="l00410"></a>00410         {
<a name="l00411"></a>00411                 <span class="keywordflow">return</span>;
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413         <span class="keywordflow">else</span>
<a name="l00414"></a>00414         {
<a name="l00415"></a>00415 <span class="comment">//              CV_Assert(useProvidedKeyPts &amp;&amp; (_keypoints != 0) &amp;&amp; (*_keypoints != 0));</span>
<a name="l00416"></a>00416                 keypoints = *_keypoints;
<a name="l00417"></a>00417         }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419     N = keypoints-&gt;total;
<a name="l00420"></a>00420     <span class="keywordflow">if</span>( _descriptors )
<a name="l00421"></a>00421     {
<a name="l00422"></a>00422         descriptors = cvCreateSeq( 0, <span class="keyword">sizeof</span>(CvSeq),
<a name="l00423"></a>00423             descriptor_size*CV_ELEM_SIZE(descriptor_data_type), storage );
<a name="l00424"></a>00424         cvSeqPushMulti( descriptors, 0, N );
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427     <span class="comment">/* Coordinates and weights of samples used to calculate orientation */</span>
<a name="l00428"></a>00428 <span class="comment">//    cv::Mat _G = cv::getGaussianKernel( 2*ORI_RADIUS+1, ORI_SIGMA, CV_32F );</span>
<a name="l00429"></a>00429 <span class="comment">//    const float* G = (const float*)_G.data;</span>
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="keywordtype">float</span> G[2*ORI_RADIUS+1];
<a name="l00432"></a>00432         CvMat _G = cvMat(1, 2*ORI_RADIUS+1, CV_32F, G);
<a name="l00433"></a>00433         getGaussianKernel(&amp;_G, 2*ORI_RADIUS+1, ORI_SIGMA, CV_32F );
<a name="l00434"></a>00434 <span class="comment">//      CvSepFilter::init_gaussian_kernel( &amp;_G, ORI_SIGMA );</span>
<a name="l00435"></a>00435     
<a name="l00436"></a>00436     <span class="keywordflow">for</span>( i = -ORI_RADIUS; i &lt;= ORI_RADIUS; i++ )
<a name="l00437"></a>00437     {
<a name="l00438"></a>00438         <span class="keywordflow">for</span>( j = -ORI_RADIUS; j &lt;= ORI_RADIUS; j++ )
<a name="l00439"></a>00439         {
<a name="l00440"></a>00440             <span class="keywordflow">if</span>( i*i + j*j &lt;= ORI_RADIUS*ORI_RADIUS )
<a name="l00441"></a>00441             {
<a name="l00442"></a>00442                 apt[nangle0] = cvPoint(j,i);
<a name="l00443"></a>00443                 apt_w[nangle0++] = G[i+ORI_RADIUS]*G[j+ORI_RADIUS];
<a name="l00444"></a>00444             }
<a name="l00445"></a>00445         }
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     <span class="comment">/* Gaussian used to weight descriptor samples */</span>
<a name="l00449"></a>00449     {
<a name="l00450"></a>00450     <span class="keywordtype">double</span> c2 = 1./(DESC_SIGMA*DESC_SIGMA*2);
<a name="l00451"></a>00451     <span class="keywordtype">double</span> gs = 0;
<a name="l00452"></a>00452     <span class="keywordflow">for</span>( i = 0; i &lt; PATCH_SZ; i++ )
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454         <span class="keywordflow">for</span>( j = 0; j &lt; PATCH_SZ; j++ )
<a name="l00455"></a>00455         {
<a name="l00456"></a>00456             <span class="keywordtype">double</span> x = j - (float)(PATCH_SZ-1)/2, y = i - (float)(PATCH_SZ-1)/2;
<a name="l00457"></a>00457             <span class="keywordtype">double</span> val = exp(-(x*x+y*y)*c2);
<a name="l00458"></a>00458             DW[i][j] = (float)val;
<a name="l00459"></a>00459             gs += val;
<a name="l00460"></a>00460         }
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462     cvScale( &amp;_DW, &amp;_DW, 1./gs );
<a name="l00463"></a>00463     }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465     win_bufs = (CvMat**)cvAlloc(nthreads*<span class="keyword">sizeof</span>(win_bufs[0]));
<a name="l00466"></a>00466     <span class="keywordflow">for</span>( i = 0; i &lt; nthreads; i++ )
<a name="l00467"></a>00467         win_bufs[i] = 0;
<a name="l00468"></a>00468 
<a name="l00469"></a>00469 <span class="preprocessor">#define _OPENMP</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span><span class="preprocessor">#ifdef _OPENMP</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span><span class="preprocessor">#pragma omp parallel for num_threads(nthreads) schedule(dynamic)</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( k = 0; k &lt; N; k++ )
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475         <span class="keyword">const</span> <span class="keywordtype">int</span>* sum_ptr = sum-&gt;data.i;
<a name="l00476"></a>00476         <span class="keywordtype">int</span> sum_cols = sum-&gt;cols;
<a name="l00477"></a>00477         <span class="keywordtype">int</span> i, j, kk, x, y, nangle;
<a name="l00478"></a>00478         <span class="keywordtype">float</span> X[max_ori_samples], Y[max_ori_samples], angle[max_ori_samples];
<a name="l00479"></a>00479         uchar PATCH[PATCH_SZ+1][PATCH_SZ+1];
<a name="l00480"></a>00480         <span class="keywordtype">float</span> DX[PATCH_SZ][PATCH_SZ], DY[PATCH_SZ][PATCH_SZ];
<a name="l00481"></a>00481         CvMat _X = cvMat(1, max_ori_samples, CV_32F, X);
<a name="l00482"></a>00482         CvMat _Y = cvMat(1, max_ori_samples, CV_32F, Y);
<a name="l00483"></a>00483         CvMat _angle = cvMat(1, max_ori_samples, CV_32F, angle);
<a name="l00484"></a>00484         CvMat _patch = cvMat(PATCH_SZ+1, PATCH_SZ+1, CV_8U, PATCH);
<a name="l00485"></a>00485         <span class="keywordtype">float</span>* vec;
<a name="l00486"></a>00486         CvSurfHF dx_t[NX], dy_t[NY];
<a name="l00487"></a>00487         <span class="keywordtype">int</span> thread_idx = cvGetThreadNum();
<a name="l00488"></a>00488         
<a name="l00489"></a>00489         CvSURFPoint* kp = (CvSURFPoint*)cvGetSeqElem( keypoints, k );
<a name="l00490"></a>00490         <span class="keywordtype">int</span> size = kp-&gt;size;
<a name="l00491"></a>00491         CvPoint2D32f center = kp-&gt;pt;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493         <span class="comment">/* The sampling intervals and wavelet sized for selecting an orientation</span>
<a name="l00494"></a>00494 <span class="comment">           and building the keypoint descriptor are defined relative to &apos;s&apos; */</span>
<a name="l00495"></a>00495         <span class="keywordtype">float</span> s = (float)size*1.2f/9.0f;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         <span class="comment">/* To find the dominant orientation, the gradients in x and y are</span>
<a name="l00498"></a>00498 <span class="comment">           sampled in a circle of radius 6s using wavelets of size 4s.</span>
<a name="l00499"></a>00499 <span class="comment">           We ensure the gradient wavelet size is even to ensure the </span>
<a name="l00500"></a>00500 <span class="comment">           wavelet pattern is balanced and symmetric around its center */</span>
<a name="l00501"></a>00501         <span class="keywordtype">int</span> grad_wav_size = 2*cvRound( 2*s );
<a name="l00502"></a>00502         <span class="keywordflow">if</span> ( sum-&gt;rows &lt; grad_wav_size || sum-&gt;cols &lt; grad_wav_size )
<a name="l00503"></a>00503         {
<a name="l00504"></a>00504             <span class="comment">/* when grad_wav_size is too big,</span>
<a name="l00505"></a>00505 <span class="comment">             * the sampling of gradient will be meaningless</span>
<a name="l00506"></a>00506 <span class="comment">             * mark keypoint for deletion. */</span>
<a name="l00507"></a>00507             kp-&gt;size = -1;
<a name="l00508"></a>00508             <span class="keywordflow">continue</span>;
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         wResizeHaarPattern( dx_s, dx_t, NX, 4, grad_wav_size, sum-&gt;cols );
<a name="l00511"></a>00511         wResizeHaarPattern( dy_s, dy_t, NY, 4, grad_wav_size, sum-&gt;cols );
<a name="l00512"></a>00512         <span class="keywordflow">for</span>( kk = 0, nangle = 0; kk &lt; nangle0; kk++ )
<a name="l00513"></a>00513         {
<a name="l00514"></a>00514             <span class="keyword">const</span> <span class="keywordtype">int</span>* ptr;
<a name="l00515"></a>00515             <span class="keywordtype">float</span> vx, vy;
<a name="l00516"></a>00516             x = cvRound( center.x + apt[kk].x*s - (<span class="keywordtype">float</span>)(grad_wav_size-1)/2 );
<a name="l00517"></a>00517             y = cvRound( center.y + apt[kk].y*s - (<span class="keywordtype">float</span>)(grad_wav_size-1)/2 );
<a name="l00518"></a>00518             <span class="keywordflow">if</span>( (<span class="keywordtype">unsigned</span>)y &gt;= (<span class="keywordtype">unsigned</span>)(sum-&gt;rows - grad_wav_size) ||
<a name="l00519"></a>00519                 (<span class="keywordtype">unsigned</span>)x &gt;= (<span class="keywordtype">unsigned</span>)(sum-&gt;cols - grad_wav_size) )
<a name="l00520"></a>00520                 <span class="keywordflow">continue</span>;
<a name="l00521"></a>00521             ptr = sum_ptr + x + y*sum_cols;
<a name="l00522"></a>00522             vx = wCalcHaarPattern( ptr, dx_t, 2 );
<a name="l00523"></a>00523             vy = wCalcHaarPattern( ptr, dy_t, 2 );
<a name="l00524"></a>00524             X[nangle] = vx*apt_w[kk]; Y[nangle] = vy*apt_w[kk];
<a name="l00525"></a>00525             nangle++;
<a name="l00526"></a>00526         }
<a name="l00527"></a>00527         <span class="keywordflow">if</span> ( nangle == 0 )
<a name="l00528"></a>00528         {
<a name="l00529"></a>00529             <span class="comment">/* No gradient could be sampled because the keypoint is too</span>
<a name="l00530"></a>00530 <span class="comment">             * near too one or more of the sides of the image. As we</span>
<a name="l00531"></a>00531 <span class="comment">             * therefore cannot find a dominant direction, we skip this</span>
<a name="l00532"></a>00532 <span class="comment">             * keypoint and mark it for later deletion from the sequence. */</span>
<a name="l00533"></a>00533             kp-&gt;size = -1;
<a name="l00534"></a>00534             <span class="keywordflow">continue</span>;
<a name="l00535"></a>00535         }
<a name="l00536"></a>00536         _X.cols = _Y.cols = _angle.cols = nangle;
<a name="l00537"></a>00537         cvCartToPolar( &amp;_X, &amp;_Y, 0, &amp;_angle, 1 );
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordtype">float</span> bestx = 0, besty = 0, descriptor_mod = 0;
<a name="l00540"></a>00540         <span class="keywordflow">for</span>( i = 0; i &lt; 360; i += ORI_SEARCH_INC )
<a name="l00541"></a>00541         {
<a name="l00542"></a>00542             <span class="keywordtype">float</span> sumx = 0, sumy = 0, temp_mod;
<a name="l00543"></a>00543             <span class="keywordflow">for</span>( j = 0; j &lt; nangle; j++ )
<a name="l00544"></a>00544             {
<a name="l00545"></a>00545                 <span class="keywordtype">int</span> d = abs(cvRound(angle[j]) - i);
<a name="l00546"></a>00546                 <span class="keywordflow">if</span>( d &lt; ORI_WIN/2 || d &gt; 360-ORI_WIN/2 )
<a name="l00547"></a>00547                 {
<a name="l00548"></a>00548                     sumx += X[j];
<a name="l00549"></a>00549                     sumy += Y[j];
<a name="l00550"></a>00550                 }
<a name="l00551"></a>00551             }
<a name="l00552"></a>00552             temp_mod = sumx*sumx + sumy*sumy;
<a name="l00553"></a>00553             <span class="keywordflow">if</span>( temp_mod &gt; descriptor_mod )
<a name="l00554"></a>00554             {
<a name="l00555"></a>00555                 descriptor_mod = temp_mod;
<a name="l00556"></a>00556                 bestx = sumx;
<a name="l00557"></a>00557                 besty = sumy;
<a name="l00558"></a>00558             }
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561         <span class="keywordtype">float</span> descriptor_dir = cvFastArctan( besty, bestx );
<a name="l00562"></a>00562         kp-&gt;dir = descriptor_dir;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564         <span class="keywordflow">if</span>( !_descriptors )
<a name="l00565"></a>00565             <span class="keywordflow">continue</span>;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567         descriptor_dir *= (float)(CV_PI/180);
<a name="l00568"></a>00568         
<a name="l00569"></a>00569         <span class="comment">/* Extract a window of pixels around the keypoint of size 20s */</span>
<a name="l00570"></a>00570         <span class="keywordtype">int</span> win_size = (int)((PATCH_SZ+1)*s);
<a name="l00571"></a>00571         <span class="keywordflow">if</span>( win_bufs[thread_idx] == 0 || win_bufs[thread_idx]-&gt;cols &lt; win_size*win_size )
<a name="l00572"></a>00572         {
<a name="l00573"></a>00573             cvReleaseMat( &amp;win_bufs[thread_idx] );
<a name="l00574"></a>00574             win_bufs[thread_idx] = cvCreateMat( 1, win_size*win_size, CV_8U );
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576         
<a name="l00577"></a>00577         CvMat win = cvMat(win_size, win_size, CV_8U, win_bufs[thread_idx]-&gt;data.ptr);
<a name="l00578"></a>00578         <span class="keywordtype">float</span> sin_dir = sin(descriptor_dir);
<a name="l00579"></a>00579         <span class="keywordtype">float</span> cos_dir = cos(descriptor_dir) ;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581         <span class="comment">/* Subpixel interpolation version (slower). Subpixel not required since</span>
<a name="l00582"></a>00582 <span class="comment">           the pixels will all get averaged when we scale down to 20 pixels */</span>
<a name="l00583"></a>00583         <span class="comment">/*  </span>
<a name="l00584"></a>00584 <span class="comment">        float w[] = { cos_dir, sin_dir, center.x,</span>
<a name="l00585"></a>00585 <span class="comment">                      -sin_dir, cos_dir , center.y };</span>
<a name="l00586"></a>00586 <span class="comment">        CvMat W = cvMat(2, 3, CV_32F, w);</span>
<a name="l00587"></a>00587 <span class="comment">        cvGetQuadrangleSubPix( img, &amp;win, &amp;W );</span>
<a name="l00588"></a>00588 <span class="comment">        */</span>
<a name="l00589"></a>00589 
<a name="l00590"></a>00590         <span class="comment">/* Nearest neighbour version (faster) */</span>
<a name="l00591"></a>00591         <span class="keywordtype">float</span> win_offset = -(float)(win_size-1)/2;
<a name="l00592"></a>00592         <span class="keywordtype">float</span> start_x = center.x + win_offset*cos_dir + win_offset*sin_dir;
<a name="l00593"></a>00593         <span class="keywordtype">float</span> start_y = center.y - win_offset*sin_dir + win_offset*cos_dir;
<a name="l00594"></a>00594         uchar* WIN = win.data.ptr;
<a name="l00595"></a>00595         <span class="keywordflow">for</span>( i=0; i&lt;win_size; i++, start_x+=sin_dir, start_y+=cos_dir )
<a name="l00596"></a>00596         {
<a name="l00597"></a>00597             <span class="keywordtype">float</span> pixel_x = start_x;
<a name="l00598"></a>00598             <span class="keywordtype">float</span> pixel_y = start_y;
<a name="l00599"></a>00599             <span class="keywordflow">for</span>( j=0; j&lt;win_size; j++, pixel_x+=cos_dir, pixel_y-=sin_dir )
<a name="l00600"></a>00600             {
<a name="l00601"></a>00601                 <span class="keywordtype">int</span> x = cvRound( pixel_x );
<a name="l00602"></a>00602                 <span class="keywordtype">int</span> y = cvRound( pixel_y );
<a name="l00603"></a>00603                 x = MAX( x, 0 );
<a name="l00604"></a>00604                 y = MAX( y, 0 );
<a name="l00605"></a>00605                 x = MIN( x, img-&gt;cols-1 );
<a name="l00606"></a>00606                 y = MIN( y, img-&gt;rows-1 );
<a name="l00607"></a>00607                 WIN[i*win_size + j] = img-&gt;data.ptr[y*img-&gt;step+x];
<a name="l00608"></a>00608              }
<a name="l00609"></a>00609         }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611         <span class="comment">/* Scale the window to size PATCH_SZ so each pixel&apos;s size is s. This</span>
<a name="l00612"></a>00612 <span class="comment">           makes calculating the gradients with wavelets of size 2s easy */</span>
<a name="l00613"></a>00613         cvResize( &amp;win, &amp;_patch, CV_INTER_AREA );
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         <span class="comment">/* Calculate gradients in x and y with wavelets of size 2s */</span>
<a name="l00616"></a>00616         <span class="keywordflow">for</span>( i = 0; i &lt; PATCH_SZ; i++ )
<a name="l00617"></a>00617             <span class="keywordflow">for</span>( j = 0; j &lt; PATCH_SZ; j++ )
<a name="l00618"></a>00618             {
<a name="l00619"></a>00619                 <span class="keywordtype">float</span> dw = DW[i][j];
<a name="l00620"></a>00620                 <span class="keywordtype">float</span> vx = (PATCH[i][j+1] - PATCH[i][j] + PATCH[i+1][j+1] - PATCH[i+1][j])*dw;
<a name="l00621"></a>00621                 <span class="keywordtype">float</span> vy = (PATCH[i+1][j] - PATCH[i][j] + PATCH[i+1][j+1] - PATCH[i][j+1])*dw;
<a name="l00622"></a>00622                 DX[i][j] = vx;
<a name="l00623"></a>00623                 DY[i][j] = vy;
<a name="l00624"></a>00624             }
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">/* Construct the descriptor */</span>
<a name="l00627"></a>00627         vec = (<span class="keywordtype">float</span>*)cvGetSeqElem( descriptors, k );
<a name="l00628"></a>00628         <span class="keywordflow">for</span>( kk = 0; kk &lt; (int)(descriptors-&gt;elem_size/<span class="keyword">sizeof</span>(vec[0])); kk++ )
<a name="l00629"></a>00629             vec[kk] = 0;
<a name="l00630"></a>00630         <span class="keywordtype">double</span> square_mag = 0;       
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         <span class="comment">/* always 36-bin descriptor */</span>
<a name="l00633"></a>00633         <span class="keywordflow">for</span>( i = 0; i &lt; 3; i++ )
<a name="l00634"></a>00634             <span class="keywordflow">for</span>( j = 0; j &lt; 3; j++ )
<a name="l00635"></a>00635             {
<a name="l00636"></a>00636                 <span class="keywordflow">for</span>( y = i*5; y &lt; i*5+5; y++ )
<a name="l00637"></a>00637                 {
<a name="l00638"></a>00638                     <span class="keywordflow">for</span>( x = j*5; x &lt; j*5+5; x++ )
<a name="l00639"></a>00639                     {
<a name="l00640"></a>00640                         <span class="keywordtype">float</span> tx = DX[y][x];
<a name="l00641"></a>00641                                                 <span class="keywordtype">float</span> ty = DY[y][x];
<a name="l00642"></a>00642                         vec[0] += tx;
<a name="l00643"></a>00643                                                 vec[1] += ty;
<a name="l00644"></a>00644                         vec[2] += (float)fabs(tx);
<a name="l00645"></a>00645                                                 vec[3] += (float)fabs(ty);
<a name="l00646"></a>00646                     }
<a name="l00647"></a>00647                 }
<a name="l00648"></a>00648                 <span class="keywordflow">for</span>( kk = 0; kk &lt; 4; kk++ )
<a name="l00649"></a>00649                     square_mag += vec[kk]*vec[kk];
<a name="l00650"></a>00650                 vec+=4;
<a name="l00651"></a>00651                         }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653         <span class="comment">/* unit vector is essential for contrast invariance */</span>
<a name="l00654"></a>00654         vec = (<span class="keywordtype">float</span>*)cvGetSeqElem( descriptors, k );
<a name="l00655"></a>00655         <span class="keywordtype">double</span> scale = 1./(sqrt(square_mag) + DBL_EPSILON);
<a name="l00656"></a>00656         <span class="keywordflow">for</span>( kk = 0; kk &lt; descriptor_size; kk++ )
<a name="l00657"></a>00657             vec[kk] = (<span class="keywordtype">float</span>)(vec[kk]*scale);
<a name="l00658"></a>00658     }
<a name="l00659"></a>00659     
<a name="l00660"></a>00660     <span class="comment">/* remove keypoints that were marked for deletion */</span>
<a name="l00661"></a>00661     <span class="keywordflow">for</span> ( i = 0; i &lt; N; i++ )
<a name="l00662"></a>00662     {
<a name="l00663"></a>00663         CvSURFPoint* kp = (CvSURFPoint*)cvGetSeqElem( keypoints, i );
<a name="l00664"></a>00664         <span class="keywordflow">if</span> ( kp-&gt;size == -1 )
<a name="l00665"></a>00665         {
<a name="l00666"></a>00666             cvSeqRemove( keypoints, i );
<a name="l00667"></a>00667             <span class="keywordflow">if</span> ( _descriptors )
<a name="l00668"></a>00668                 cvSeqRemove( descriptors, i );
<a name="l00669"></a>00669             k--;
<a name="l00670"></a>00670             N--;
<a name="l00671"></a>00671         }
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674     <span class="keywordflow">for</span>( i = 0; i &lt; nthreads; i++ )
<a name="l00675"></a>00675         cvReleaseMat( &amp;win_bufs[i] );
<a name="l00676"></a>00676 
<a name="l00677"></a>00677     <span class="keywordflow">if</span>( _keypoints &amp;&amp; !useProvidedKeyPts )
<a name="l00678"></a>00678         *_keypoints = keypoints;
<a name="l00679"></a>00679     <span class="keywordflow">if</span>( _descriptors )
<a name="l00680"></a>00680         *_descriptors = descriptors;
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     cvReleaseMat( &amp;sum );
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (mask1) cvReleaseMat( &amp;mask1 );
<a name="l00684"></a>00684     <span class="keywordflow">if</span> (mask_sum) cvReleaseMat( &amp;mask_sum );
<a name="l00685"></a>00685     cvFree( &amp;win_bufs );
<a name="l00686"></a>00686 }
<a name="l00687"></a>00687 
<a name="l00690"></a>00690 <span class="preprocessor">#endif</span>
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Fri Aug 28 02:30:51 2009 for windage library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
