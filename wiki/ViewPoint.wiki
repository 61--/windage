== Introduction ==
The View Point Solution draw environment map and change view point based on received data.(from MPT colortracker)

== To Draw Environment Map ==

=== Make Cubemap Skybox ===
{{{
#define SKYFRONT 0						// Give Front ID = 0
#define SKYBACK  1						// Give Back  ID = 1
#define SKYLEFT  2						// Give Left  ID = 2
#define SKYRIGHT 3						// Give Right ID = 3
#define SKYUP    4						// Give Up    ID = 4
#define SKYDOWN  5						// Give Down  ID = 5

UINT texturePointer[6];
for(int ID=0; ID<6; ID++)
{
	glGenTextures(1, &textureArray[ID]);
	glBindTexture(GL_TEXTURE_2D, textureArray[ID]);
	gluBuild2DMipmaps(GL_TEXTURE_2D, 3, textureImage[ID]->width, textureImage[ID]->height, GL_RGB, GL_UNSIGNED_BYTE, textureImage[ID]->imageData);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);
}

void MakeCubemapSkybox(float x, float y, float z, float width, float height, float length)
{
	// Center the Skybox around the given x,y,z position
	x = x - width  / 2;
	y = y - height / 2;
	z = z - length / 2;

	// Draw Front side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYFRONT]);
	glBegin(GL_QUADS);	
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x,		  y,		z+length);
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x,		  y+height, z+length);
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x+width, y+height, z+length); 
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x+width, y,		z+length);
	glEnd();

	// Draw Back side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYBACK]);
	glBegin(GL_QUADS);		
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x+width, y,		z);
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x+width, y+height, z); 
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x,		  y+height,	z);
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x,		  y,		z);
	glEnd();

	// Draw Left side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYLEFT]);
	glBegin(GL_QUADS);		
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x,		  y+height,	z);	
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x,		  y+height,	z+length); 
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x,		  y,		z+length);
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x,		  y,		z);		
	glEnd();

	// Draw Right side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYRIGHT]);
	glBegin(GL_QUADS);		
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x+width, y,		z);
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x+width, y,		z+length);
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x+width, y+height,	z+length); 
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x+width, y+height,	z);
	glEnd();

	// Draw Up side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYUP]);
	glBegin(GL_QUADS);		
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x+width, y+height, z);
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x+width, y+height, z+length); 
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x,		  y+height,	z+length);
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x,		  y+height,	z);
	glEnd();

	// Draw Down side
	glBindTexture(GL_TEXTURE_2D, SkyboxTexture[SKYDOWN]);
	glBegin(GL_QUADS);		
		glTexCoord2f(0.0f, 0.0f); glVertex3f(x,		  y,		z);
		glTexCoord2f(1.0f, 0.0f); glVertex3f(x,		  y,		z+length);
		glTexCoord2f(1.0f, 1.0f); glVertex3f(x+width, y,		z+length); 
		glTexCoord2f(0.0f, 1.0f); glVertex3f(x+width, y,		z);
	glEnd();

}


}}}

=== Make Sphericalmap Skybox ===
{{{
UINT texturePointer;
glGenTextures(1, texturepointer);
glBindexture(GL_TEXTURE_2D, texturePointer)
glBuild2DMipmaps(GL_TEXTURE_2D, 3, textureImage->width, textureImage->height, GL_RGB, GL_UNSIGNED_BYTE, textureImage->imageData);
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);

#define	    PI		    3.1415926f
#define	    RADIUS	    1.0f
#define	    STEPS	    100
void MakeSphericalmapSkybox(float size)
{
	int i, j;
	float fX[4], fY[4], fZ[4];
	float fRadius = RADIUS * 10.0;
	float fPhiSteps = STEPS / 2.0f;
	float fThetaSteps = STEPS;
	float fPhi_0, fPhi_1, fTheta_0, fTheta_1;

	glBindTexture(GL_TEXTURE_2D, texturePointer);

	for ( i = 0; i < fPhiSteps; i++ )
	{
		fPhi_0 = PI * (i+0)/fPhiSteps;
		fPhi_1 = PI * (i+1)/fPhiSteps;

		fTheta_0 = -(( PI * 3.0f )/2.0f);

		fX[2] = fRadius * sin( fPhi_1 ) * cos( fTheta_0 );
		fX[3] = fRadius * sin( fPhi_0 ) * cos( fTheta_0 );

		fY[1] = fY[2] = fRadius * cos( fPhi_1 );
		fY[0] = fY[3] = fRadius * cos( fPhi_0 );

		fZ[2] = fRadius * sin( fPhi_1 ) * sin( fTheta_0 );
		fZ[3] = fRadius * sin( fPhi_0 ) * sin( fTheta_0 );

		for ( j = 0; j < fThetaSteps; j++ )
		{	 
			fTheta_1 = ( 2.0f * PI * (j+1)/fThetaSteps ) - ( PI * 3.0f/2.0f );

			fX[0] = fX[3]; 
			fX[1] = fX[2]; 
			fX[2] = fRadius * sin( fPhi_1 ) * cos( fTheta_1 );
			fX[3] = fRadius * sin( fPhi_0 ) * cos( fTheta_1 );

			fZ[0] = fZ[3];
			fZ[1] = fZ[2];
			fZ[2] = fRadius * sin( fPhi_1 ) * sin( fTheta_1 );
			fZ[3] = fRadius * sin( fPhi_0 ) * sin( fTheta_1 );

			glBegin( GL_QUADS );

			glTexCoord2f( (j+0)/fThetaSteps, (i+0)/fPhiSteps );
			glVertex3f( fX[0], fY[0], fZ[0] );

			glTexCoord2f( (j+0)/fThetaSteps, (i+1)/fPhiSteps );
			glVertex3f( fX[1], fY[1], fZ[1] );

			glTexCoord2f( (j+1)/fThetaSteps, (i+1)/fPhiSteps );
			glVertex3f( fX[2], fY[2], fZ[2] );

			glTexCoord2f( (j+1)/fThetaSteps, (i+0)/fPhiSteps );
			glVertex3f( fX[3], fY[3], fZ[3] );

			glEnd();
		}
	}
}

}}}

== To Change View Port ==

=== Interpolation for smoothing ===
 * smoothing.h
{{{
#include "../include/windageVector.h"

class Smoothing
{
private:
	Vector3 position;
	float speed;
	float threshold;

public:
	Smoothing();
	Smoothing(Vector3 pos, float spd, float thr);
	~Smoothing();

	Vector3 GetPosition();
	void SetSpeed(float updateSpeed);
	void UpdatePosition(Vector3 updatePosition);
};
}}}

 * smoothing.cpp
{{{

#include "Smoothing.h"

// Constructor
Smoothing::Smoothing()
{
	this->position.initialize();
	this->speed = 10;
	this->threshold = 0;
}

Smoothing::Smoothing(Vector3 pos, float spd, float thr)
{
	this->position = pos;
	this->speed = spd;
	this->threshold = thr;
}

Smoothing::~Smoothing()
{
}

Vector3 Smoothing::GetPosition()
{
	return this->position;
}

void Smoothing::SetSpeed(float updateSpeed)
{
	this->speed = updateSpeed;
}

void Smoothing::UpdatePosition(Vector3 updatePosition)
{
	Vector3 direction = updatePosition - this->position;

	if(direction.getLength() > (double)this->threshold)
	{
		this->position = this->position + direction.setLength((double)speed);
	}
	else
	{
		if(direction.getLength() > 0)
			this->position = this->position + direction.setLength((double)0.05);
	}
}
}}}